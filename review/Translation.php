<?php

    //    Не указан namespace для класса. Так же не указан use для InvalidConfigException
    class Translation
    {
        // Не указаны модификаторы доступа для констант. Не указан тип свойства $key
        // константа DETECT_YA_URL в данном участке кода не используется
        const DETECT_YA_URL = 'https://translate.yandex.net/api/v1.5/tr.json/detect';

        const TRANSLATE_YA_URL = 'https://translate.yandex.net/api/v1.5/tr.json/translate';

        // Для поля $key следует осуществить внедрение зависимости
        // так же нет необходимости в двойных кавычках вместо одинарных
        // само свойство следует объявить private или protected
        public $key = "AlzalyCf2zgkmk-nRxdbB4gg49M9GZhmFei55uo";

        // следует указать возвращаемое значение метода init
        // расположение фигурных скобок метода init не соответствует PSR
        public function init(){
            parent::init();
            // чей родитель? у класса Translate не указан предок - будет фаталити

            // $this->key уже прописан и поэтому условие всегда будет false
            // Т.о. вся конструкция if становится бессмысленной. Так же есть лишние пробелы в условии
            // переменная $key в сообщении не существует, а использование элементов вёрстки в сообщении - плохая практика
            // если подразумевалось создание строки вида 'Field $key is required' без подстановки значения переменной,
            // то необходимо экранировать знак \$ или использовать одинарные кавычки
            if ( empty( $this->key ) ) {
                throw new InvalidConfigException("Field <b>$key</b> is required");
            }
        }

        // в phpdoc корректнее было бы написать: @param $format string text format need to translate
        /**
         * @param $format text format need to translate
         * @return string
         */
        // необходимо уточнение сигнатуры метода: тип аргумента и тип возвращаемого значения
        // двойные кавычки в значении по умолчанию заменить на одинарные
        // имя метода не соответствует PSR - необходимо использовать camelCase
        // в аргументе по умолчанию оператор присвоения не отделён пробелами
        // сам метод перевести в динамический и разбить на несколько методов
        public static function translate_text($format="text")
        {
            // невозможно использовать свойство $this->key в контексте статического метода - будет фатальная ошибка
            // та же проблемы, что в методе init + дублирование кода. Есть смысл вынести
            if (empty($this->key)) {
                throw new InvalidConfigException("Field <b>$key</b> is required");
            }

            // устаревший синтаксис создания массива, который следует заменить на [ ]
            // название массива $values слишком абстрактно - можно дать переменной более говорящее название
            // в элементе format следует использовать строгое сравнение ===
            // формирование элемента format можно отдельно вынести в конструкцию switch или match
            $values = array(
                 'key'    => $this->key, // обращение к свойству объекта в статическом контексте
                 'text'   => $_GET['text'], // данные приходящие из GET лучше получать в виде аргументов для метода
                 'lang'   => $_GET['lang'], // после чего проводить санитаризацию
                 'format' => $format == "text" ? 'plain' : $format, // двойные кавычки лучше заменить на одинарные
            );

            $formData = http_build_query($values);

            $ch = curl_init(self::TRANSLATE_YA_URL);
            // в этом месте можно использовать curl_setopt_array
            // так же не указан CURLOPT_POST
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, $formData);

            $json = curl_exec($ch);
            curl_close($ch);

            $data = json_decode($json, true);
            // Фигурные скобки в блоке if не соответствуют PSR, оператор сравнения не отделен пробелами.
            // Возвращаемое значение - если не смотреть в документацию по API, то не ясно,
            // возвращает ли метод значение одного типа или разных.
            // Исходя из названия метод, ожидается, что он вернёт перевод текста, а не вот это вот всё
            // в случае же ошибки логичнее выбрасывать исключение,
            // а не возвращать массив. Помимо этого значение 200 лучше заменить на константу для ясности происходящего
            // (например HTTP_CODE_OK или что-то подобное)
            if ($data['code']==200) // следует использовать '==='
            {
                return $data['text'];
            }
            return $data;
            //данная конструкция if может быть заменена на: return ($data['code'] == 200) ? $data['text'] : $data

        }
        // ......
    // тело класса не закрыто
